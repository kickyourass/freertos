#define USE_STDPERIPH_DRIVER
#include "stm32f10x.h"

/* Scheduler includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"
#include <string.h>

static void setup_hardware();

volatile xQueueHandle serial_str_queue = NULL;
volatile xSemaphoreHandle serial_tx_wait_sem = NULL;
volatile xQueueHandle serial_rx_queue = NULL;


int strcmp(const char *a, const char *b) __attribute__ ((naked));
int strcmp(const char *a, const char *b)
{
	asm(
        "strcmp_lop:                \n"
        "   ldrb    r2, [r0],#1     \n"
        "   ldrb    r3, [r1],#1     \n"
        "   cmp     r2, #1          \n"
        "   it      hi              \n"
        "   cmphi   r2, r3          \n"
        "   beq     strcmp_lop      \n"
		"	sub     r0, r2, r3  	\n"
        "   bx      lr              \n"
		:::
	);
}

size_t strlen(const char *s) __attribute__ ((naked));
size_t strlen(const char *s)
{
	asm(
		"	sub  r3, r0, #1			\n"
        "strlen_loop:               \n"
		"	ldrb r2, [r3, #1]!		\n"
		"	cmp  r2, #0				\n"
        "   bne  strlen_loop        \n"
		"	sub  r0, r3, r0			\n"
		"	bx   lr					\n"
		:::
	);
}

void puts(char *s)
{
	while (*s) {
		while (USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET)
			/* wait */ ;
		USART_SendData(USART2, *s);
		s++;
	}
}

void int2str(int x,char* c_arr){
	int digit[5];
	int temp=10000,idx,i;
	
	for(i=0;i<5;i++){
		digit[i]=x/temp;
		x=x%temp;
		temp/=10;
	}
	
	for(i=0;i<5;i++){
		if(digit[i]!=0){
			for(idx=0;idx<(5-i);idx++)
				c_arr[idx]=0x30+digit[i+idx];
			c_arr[idx]='\0';
			return ;
		}
		
	}
	//for x==zero
	c_arr[0]=0x30;
	c_arr[1]=0x00;
	return ;
}


/* Queue structure used for passing messages. */
typedef struct {
	char str[100];
} serial_str_msg;

/* Queue structure used for passing characters. */
typedef struct {
	char ch;
} serial_ch_msg;

/* IRQ handler to handle USART2 interruptss (both transmit and receive
 * interrupts). */
void USART2_IRQHandler()
{
	static signed portBASE_TYPE xHigherPriorityTaskWoken;
	serial_ch_msg rx_msg;

	/* If this interrupt is for a transmit... */
	if (USART_GetITStatus(USART2, USART_IT_TXE) != RESET) {
		/* "give" the serial_tx_wait_sem semaphore to notfiy processes
		 * that the buffer has a spot free for the next byte.
		 */
		xSemaphoreGiveFromISR(serial_tx_wait_sem, &xHigherPriorityTaskWoken);

		/* Diables the transmit interrupt. */
		USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
		/* If this interrupt is for a receive... */
	}
	else if (USART_GetITStatus(USART2, USART_IT_RXNE) != RESET) {
		/* Receive the byte from the buffer. */
		rx_msg.ch = USART_ReceiveData(USART2);

		/* Queue the received byte. */
		if(!xQueueSendToBackFromISR(serial_rx_queue, &rx_msg, &xHigherPriorityTaskWoken)) {
			/* If there was an error queueing the received byte,
			 * freeze. */
			while(1);
		}
	}
	else {
		/* Only transmit and receive interrupts should be enabled.
		 * If this is another type of interrupt, freeze.
		 */
		while(1);
	}

	if (xHigherPriorityTaskWoken) {
		taskYIELD();
	}
}

void send_byte(char ch)
{
	/* Wait until the RS232 port can receive another byte (this semaphore
	 * is "given" by the RS232 port interrupt when the buffer has room for
	 * another byte.
	 */
	while (!xSemaphoreTake(serial_tx_wait_sem, portMAX_DELAY));

	/* Send the byte and enable the transmit interrupt (it is disabled by
	 * the interrupt).
	 */
	USART_SendData(USART2, ch);
	USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
}

char receive_byte()
{
	serial_ch_msg msg;

	/* Wait for a byte to be queued by the receive interrupts handler. */
	while (!xQueueReceive(serial_rx_queue, &msg, portMAX_DELAY));

	return msg.ch;
}

void led_flash_task(void *pvParameters)
{
	while (1) {
		/* Toggle the LED. */
		GPIOC->ODR = GPIOC->ODR ^ 0x00001000;

		/* Wait one second. */
		vTaskDelay(100);
	}
}

void rs232_xmit_msg_task(void *pvParameters)
{
	serial_str_msg msg;
	int curr_char;

	while (1) {
		/* Read from the queue.  Keep trying until a message is
		 * received.  This will block for a period of time (specified
		 * by portMAX_DELAY). */
		while (!xQueueReceive(serial_str_queue, &msg, portMAX_DELAY));

		/* Write each character of the message to the RS232 port. */
		curr_char = 0;
		while (msg.str[curr_char] != '\0') {
			send_byte(msg.str[curr_char]);
			curr_char++;
		}
	}
}


/* Repeatedly queues a string to be sent to the RS232.
 *   delay - the time to wait between sending messages.  A delay of 1 means
 *           wait 1/100th of a second.
 */
void queue_str_task(const char *str, int delay)
{
	serial_str_msg msg;

	/* Prepare the message to be queued. */
	strcpy(msg.str, str);

	while (1) {
		/* Post the message.  Keep on trying until it is successful. */
		while (!xQueueSendToBack(serial_str_queue, &msg,
		       portMAX_DELAY));

		/* Wait. */
		vTaskDelay(delay);
	}
}

void queue_str_task1(void *pvParameters)
{
	queue_str_task("Hello 1\n", 200);
}

void queue_str_task2(void *pvParameters)
{
	queue_str_task("Hello 2\n", 50);
}

#define KEY_ENTER 0x0D
#define KEY_BACKSPACE 0x7F
void catch_msg(serial_str_msg* msg)
{
	
	char ch;
	int curr_char;
	int done;

	
		curr_char = 0;
		done = 0;
		do {
			/* Receive a byte from the RS232 port (this call will
			 * block). */
			ch = receive_byte();
			
			
			/* If the byte is an end-of-line type character, then
			 * finish the string and inidcate we are done.
			 */
			if ( (curr_char>=sizeof(msg->str) ) || (ch == '\r') || (ch == '\n')) {
				done = -1;
				/* Otherwise, add the character to the
				 * response string. */
				puts("\r\n");

			}
			else {
				if(ch==KEY_BACKSPACE){
					if(curr_char){
						puts("\b \b");
						msg->str[curr_char--]=0x00;
					}
				}
				else{
					msg->str[curr_char++] = ch;
					send_byte(ch);
				}
			}
			
		} while (!done);

		/* Once we are done building the response string, queue the
		 * response to be sent to the RS232 port.
		 */
		while (!xQueueSendToBack(serial_str_queue, &msg,
		                         portMAX_DELAY));
	
}
extern xList pxReadyTasksLists[ configMAX_PRIORITIES ];
void ps_cmd_function(){
	char str[10];
	char pTempStr;
	int i,j,count;
	struct xLIST_ITEM *pxTemp;
	for(i=0;i<configMAX_PRIORITIES;i++){
		puts("\npriority\ttask_name");
		int2str( i,str );
		puts(str);

		pxTemp=pxReadyTasksLists[i].xListEnd.pxNext;
		count=pxReadyTasksLists[i].uxNumberOfItems;
		for(j=0;j<count;j++){
			pTempStr=((struct tskTaskControlBlock *)(pxTemp->pvOwner))->pcTaskName ;
			pxTemp=pxTemp->pxNext;
		}
		puts("\n\r");

	}

}
void my_shell_task(){
	static serial_str_msg msg;
	char pid[6];
	int fdout, fdin,  i,priority;
	while(1){
		puts("enter command:");
		catch_msg(&msg);
		if( strcmp(msg.str,"echo") ==0){
			puts("echo function:");
			catch_msg(&msg);					
			puts(msg.str);
			puts("\n\r");		
		}
		else if( strcmp(msg.str,"help") ==0){
			puts("command\tdetail\n\r");
			puts("help\tinformation about all commands\n\r");
			puts("echo\ttype a string,the shell will echo\n\r");
			puts("hello\tshow the greetings\n\r");
			puts("ps\tshow the PID and Priority of all undergoing tasks\n\r");
			puts("add_proc\tadd a dummy task \n\r");
			puts("host cmd\tcommand on host bash \n\r");
		}
		else if( strcmp(msg.str,"hello") ==0){
			puts("helloWorld!\n\r");
		}
		else if( strcmp(msg.str,"ps") ==0){
			puts("Number of undergoing tasks:");
			ps_cmd_function();
			puts("\n\r");
		}
		/*else if( strcmp(str_buf,"add_proc") ==0){
			if(!fork()){
				dummy_func();	
			}
		}
		else if( strcmp(str_buf,"kill") ==0){
			puts("enter pid:");
			catch_msg(str_buf,10);
			kill(str2int(str_buf) );
		}
		else if( strcmp(str_buf,"host cmd") ==0){
			puts("enter cmd:");
			catch_msg(str_buf,10);
			host_sys_cmd(str_buf);
		}
		else{
			puts(str_buf);
			puts(" is invalid command\n\r");
		}*/
	}
}
void my_dummy_task(){
	while(1);
}
int main()
{
	init_led();

	init_button();
	enable_button_interrupts();

	init_rs232();
	enable_rs232_interrupts();
	enable_rs232();

	fs_init();
	fio_init();
	/* Create the queue used by the serial task.  Messages for write to
	 * the RS232. */
	serial_str_queue = xQueueCreate(10, sizeof(serial_str_msg));
	vSemaphoreCreateBinary(serial_tx_wait_sem);
	serial_rx_queue = xQueueCreate(1, sizeof(serial_ch_msg));

	
	/* Create a task to receive characters from the RS232 port and echo
	 * them back to the RS232 port. */
	xTaskCreate(my_shell_task,
	            (signed portCHAR *) "Serial Read/Write",
	            512 /* stack size */, NULL,
	            tskIDLE_PRIORITY + 10, NULL);
	/*dummy*/
	xTaskCreate(my_dummy_task,
	            (signed portCHAR *) "dummy",
	            512 /* stack size */, NULL,
	            tskIDLE_PRIORITY , NULL);

	/* Start running the tasks. */
	vTaskStartScheduler();

	return 0;
}

void myTraceCreate      (){
}

void myTraceSwitchedIn  (){
}

void myTraceSwitchedOut	(){
}
/*
inline float myTraceGetTick(){
	// 0xE000E014 -> Systick reload value
	// 0xE000E018 -> Systick current value
	return ((float)((*(unsigned long *)0xE000E014)-(*(unsigned long *)0xE000E018)))/(*(unsigned long *)0xE000E014);
}

inline unsigned long myTraceGetTimeMillisecond(){
	return (xTaskGetTickCountFromISR() + myTraceGetTick()) * 1000 / configTICK_RATE_HZ;
}
*/
void vApplicationTickHook()
{
}
